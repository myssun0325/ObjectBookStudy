# 3장. 역할, 책임, 협력

- 상속은 재사용하기 좋은 메커니즘이지만 캡슐화 측면에서는 합성이 더 좋은 방법.
- 2장 리뷰; 다형성은 지연 바인딩이라는 메커니즘을 통해 구현된다.
  - 지연 바인딩이란(lazy binding) : 실행될 메서드를 컴파일 시점이 아닌 실행 시점에 결정한다. -> 메시지와 메서드를 실행 시점에 바인딩 한다. 동적 바인딩(lazy binding)과 같은 말.
  - 반대로 전통적인 함수 호출처럼 컴파일 시점에 실행될 함수나 프로시저를 결정하는 것을 __초기바인딩(early binding)__ 또는 __정적 바인딩(static binding)__ 이라고 한다.
- 애플리케이션의 기능을 구현하기 위해 수행하는 작용 - __협력__
- p.75 객체가 협력에 참여하기 위해 수행하는 로직 - __책임__
- 객체들이 협력 안에서 수행하는 책임들이 모여 객체가 수행하는 __역할__을구성한다.

- 객체간의 메시지 전송(message sending) (objective-c 문법은 좀 더 이 부분을 직관적으로 보여준다.)
- _협력을 설계할 때는 객체를 서로 분리된 인스턴스가 아닌 협력하는 파트로 인식해야 한다._
  - 기존에 무조건 객체를 분리하기 위한답시고 독립적인 존재로 인식 X (협력을 할 뿐 의존성을 높이진 말자?)
- 캡슐화가 가져다주는 여러 장점들(ex. 느슨한 결합도 등)
- 애플리케이션 안에 어떤 객체가 필요하다면 그 이유는 단 하나여야 한다.
  - 객체의 행동을 결정하는 것은 객체가 참여하고 있는 협력이다.
- 객체의 행동을 결정하는 것이 협력이라 객체의 상태를 결정하는 것은 행동이다.
- 객체지향 설게에서 가장 중요한 것은 책임이다.
- 메시지가 객체를 결정한다.
  - 객체에게 책임을 할당하는 데 필요한 메시지를 먼저 식별하 메시지를 처리할 객체를 나중에 선택하는 것이 중요.
  - 객체가 메시지를 선택하는 것이 아니라 메시지가 객체를 선택하는 것이다.
  - 메시지가 개체를 선택해야 하는 두 가지 중요한 이유
    1. 객체가 최소한의 인터페이를 가질 수 있게 된다.
    2. 객체는 충분히 추상적인 인터페이를 가질 수 있게 된다.
- 객체의 행동이 아니라 상태에 초점을 맞추는 것을 지양하라.
- 역할 없이 협력을 구현한 잘못된 예 -> p.87, p.88 (코드 중복)
  - 역할이 있기 때문에 대체가능하다.
- **문제를 해결하기 위해서 객체가 아닌 책임에 초점을 맞춰야 한다.** (책 이름은 객체이지만...)
- 다양한 객체들이 협력에 참여하다는 것이 확실하다면 __역할__ 로 시작하라.
- 결국 제가 생각하기에 __역할__ == __프로토콜__ 인듯.
- 중요한 것은 협력을 구체적인 객체가 아니라 추상적인 역할의 관점에서 설계하면 협력이 유연하고 재사용 가능해진다는 것이다.



# 4장. 설계 품질과 트레이드오프

- 책임 주도 설계라는 이름에서 알 수 있는 것처럼 역할, 책임, 협력 중에서 가장 중요한 것은 __책임__ 이다.
  - 객체지향 설계란 올바른 책임을 할당하면서 __낮은 결합도__와 __높은 응집도__를 가진 구조를 창조하는 활동이다.
  - 책임이 핵심이, 책임을 할당하는 작업이 응집도와 결합도 같은 설계 품질과 연계되어 있다.
- 매우 강조 : _객체의 상태가 아니라 객체의 행동에 초점을 맞추는 것이다._
  - 나아가 _객체와 객체 사이의 상호작용_으로 설계 중심을 이동시킨다.
- 데이터 중심으로 보지 말자. 
  - 데이터가 아니라 책임에 초점을 맞춰야 하는 이유는 변경과 관련이 있기 때문이다. 객체의 상태는 구현에 속하는데 구현은 불안정하기 때문에 쉽게 변한다. -> 구현에 의존적 -> 결국 캡슐화가 무너짐 -> 변경에 취약

- 4장의 데이터 중심의 접근 방법은 굉장히 인상적 -> 우리가 쉽게 저지를 수 있는 예임.
- "이 객체가 포함해야 하는 데이터는 무엇인가?"라는 질문을 자주한다면 의심해보자...
- 변경될 가능성이 높은 부분 -> 구현, 상대적으로 안정적인 부분 -> 인터페이스
- 객체지향 원리에서 가장 중요한 원리는 __캡슐화__ (불안정한 구현 세부사항을 안정적인 인터페이스 뒤로 캡슐화 하는 것.)
- 설계가 필요한 이유는 요구사항이 변경되기 때문.
- 응집도와 결합도는 결국 변경과 관련이 깊다.
- 캡슐화 위반
```swift
class Movie {
 private var fee: Money
 
 func getFee() -> Money {
 return fee
 }
 
 func setFee(fee: Money) {
 self.fee = fee
 }
}
```

- 비교
```swift
class Movie {
 private var fee: Money
 private var discountPolicy: DisCountPolicy
 
 func calculateMovieFee(screening: Screening) {
	 return fee.minius(discountPolicy.calculateDiscountAmount(screening))
 }
}
```



- 􏸒속성의 가시성을 private으로 설정했다고 해도 접근자와 수정자를 통해 속성을 외부로 제공하고 있다면 캡슐화를 위반하는 것이다.
- 결국 데이터 중심의 설계에 대한 얘기를 계속 하고 있음.
- 데이터 중심의 설계에서는 초점이 객체의 외부가 아니라 내부로 향한다.
- 객체의 구현이 이미 결정된 상태에서 다른 객체와의 협력 방법을 고민하기 때문에 이미 구현된 객체의 인터페이스를 억지로 끼워맞출 수 밖에 없다.
- 객체의 인터페이스에 구현이 노출되지 않는지 점검해보기.



---



### Discussion

- p.90, 객체 대 역할에서 결국 그래서 오직 한 종류의 객체만 협력하는 상황에서도 역할을 사용하라는건지, 말라는 건지?
  - 애매하면 단순하게 객체로 시작해서 반복적으로 책임과 협력을 정제해가면서 필요한 순간에 객체로부터 역할을 분리해내는게 가장 좋은 방법이다. > 결국 객체로 시작하라는 건가.?

- "예매하라" 메시지 전달 > Screening(객체) > 예매하라를 필요한 행동? 또 다른 행동 > "가격을 계산하라" > Screening안에서 저 가격을 "계산하라"를 수행하기 위해서 어떤것들이 필요한지 > Movie
